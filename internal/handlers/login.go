package handlers

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"goth/internal/templates"
	"net/http"
	"net/url"
	"strings"
)

// create a struct ApiHandler
// inside ApiHandler add a cach√© of last responses?
// go from string [query] to object response

func (cfg *SpotifyApi) RequestUserAuthorizationHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Println("login")

	baseUrl := "https://accounts.spotify.com/authorize"

	url, err := url.Parse(baseUrl)
	if err != nil {
		errmsg := fmt.Sprintf("Error parsing URL: %v", err)
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}

	query := url.Query()
	query.Set("client_id", cfg.Config.ClientID)
	query.Set("response_type", "code")
	query.Set("redirect_uri", "http://127.0.0.1:8080/auth/callback")
	query.Set("state", cfg.Config.State)
	query.Set("scope", "user-read-playback-state user-read-private user-read-email user-modify-playback-state")

	url.RawQuery = query.Encode()
	http.Redirect(w, r, url.String(), http.StatusFound)

}

func (cfg *SpotifyApi) RequestUserAuthorizationCallbackHandler(w http.ResponseWriter, r *http.Request) {

	// Check response
	respError := r.URL.Query().Get("error")
	respCode := r.URL.Query().Get("code")
	respState := r.URL.Query().Get("state")
	if respState != cfg.Config.State {
		errmsg := fmt.Sprintln("could not validate state")
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}
	if respError != "" {
		errmsg := fmt.Sprintf("could not get authorization user: %v", respError)
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}
	if respCode == "" {
		errmsg := fmt.Sprintf("could not retrieve code: %v", respError)
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}
	cfg.Config.AuthorizationCode = respCode

	// Request AccessToken
	baseUrl := "https://accounts.spotify.com/api/token"
	data := url.Values{}
	data.Set("grant_type", "authorization_code")
	data.Set("code", cfg.Config.AuthorizationCode)
	data.Set("redirect_uri", "http://127.0.0.1:8080/auth/callback")

	request, err := http.NewRequest("POST", baseUrl, bytes.NewBufferString(data.Encode()))
	if err != nil {
		errmsg := fmt.Sprintf("could not create request: %v", err)
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}
	request.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	encoded := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%v:%v", cfg.Config.ClientID, cfg.Config.ClientSecret)))
	request.Header.Set("Authorization", fmt.Sprintf("Basic %v", encoded))
	client := &http.Client{}
	resp, err := client.Do(request)
	if err != nil {
		errmsg := fmt.Sprintf("could not do request: %v", err)
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}
	defer resp.Body.Close()

	// Check response
	type AccessTokenResp struct {
		AccessToken  string `json:"access_token"`
		TokenType    string `json:"token_type"`
		Scope        string `json:"scope"`
		ExpiresIn    int    `json:"expires_in"`
		RefreshToken string `json:"refresh_token"`
	}

	var accessTokenResp AccessTokenResp
	err = json.NewDecoder(resp.Body).Decode(&accessTokenResp)
	if err != nil {
		errmsg := fmt.Sprintf("could not decode response: %v", err)
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}

	cfg.Config.AccessToken = accessTokenResp.AccessToken
	cfg.Config.RefreshToken = accessTokenResp.RefreshToken

	http.Redirect(w, r, "http://127.0.0.1:8080", http.StatusFound)
}

func (cfg *SpotifyApi) RequestStartHandler(w http.ResponseWriter, r *http.Request) {

	type AutoGenerated struct {
		ContextURI string `json:"context_uri"`
		Offset     struct {
			Position int `json:"position"`
		} `json:"offset"`
		PositionMs int `json:"position_ms"`
	}

	// Set request
	req, err := http.NewRequest("PUT", "https://api.spotify.com/v1/me/player/play", nil)
	if err != nil {
		errmsg := fmt.Sprintf("could not create request for me: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %v", cfg.Config.AccessToken))
	client := http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		errmsg := fmt.Sprintf("could not do request for me: %v", err)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}
	if resp.StatusCode != http.StatusNoContent {
		errmsg := fmt.Sprintf("could not get good status code: %v", resp.StatusCode)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write([]byte("Playing"))
}

func (cfg *SpotifyApi) AlbumGridHttp(w http.ResponseWriter, r *http.Request) {



	fmt.Println("", r.URL.RawQuery)
	query := strings.ToLower(r.URL.Query().Get("search"))

	fmt.Println("queyr:", query)
	artistId := strings.ToLower(r.URL.Query().Get("artistId"))

	fmt.Println("artistId:", artistId)
	if artistId == "" {
		errmsg := fmt.Sprintln("no artist provided")
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(errmsg))
		return
	}
	// Set request
	requestUrl := fmt.Sprintf("https://api.spotify.com/v1/artists/%v/albums", artistId)
	fmt.Println(requestUrl)
	req, err := http.NewRequest("GET", requestUrl, nil)
	if err != nil {
		errmsg := fmt.Sprintf("could not create request: %v", err)
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %v", cfg.Config.AccessToken))

	client := http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		errmsg := fmt.Sprintf("could not do request: %v", err)
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}
	if resp.StatusCode != http.StatusOK {
		errmsg := fmt.Sprintf("could not get good status code: %v", resp.StatusCode)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}
	defer resp.Body.Close()

	type AlbumsResp struct {
		Href     string      `json:"href"`
		Limit    int         `json:"limit"`
		Next     string      `json:"next"`
		Offset   int         `json:"offset"`
		Previous interface{} `json:"previous"`
		Total    int         `json:"total"`
		Items    []struct {
			AlbumType        string   `json:"album_type"`
			TotalTracks      int      `json:"total_tracks"`
			AvailableMarkets []string `json:"available_markets"`
			ExternalUrls     struct {
				Spotify string `json:"spotify"`
			} `json:"external_urls"`
			Href   string `json:"href"`
			ID     string `json:"id"`
			Images []struct {
				URL    string `json:"url"`
				Height int    `json:"height"`
				Width  int    `json:"width"`
			} `json:"images"`
			Name                 string `json:"name"`
			ReleaseDate          string `json:"release_date"`
			ReleaseDatePrecision string `json:"release_date_precision"`
			Type                 string `json:"type"`
			URI                  string `json:"uri"`
			Artists              []struct {
				ExternalUrls struct {
					Spotify string `json:"spotify"`
				} `json:"external_urls"`
				Href string `json:"href"`
				ID   string `json:"id"`
				Name string `json:"name"`
				Type string `json:"type"`
				URI  string `json:"uri"`
			} `json:"artists"`
			AlbumGroup string `json:"album_group"`
		} `json:"items"`
	}

	var albumResp AlbumsResp
	err = json.NewDecoder(resp.Body).Decode(&albumResp)
	if err != nil {
		errmsg := fmt.Sprintf("could not decode response: %v", err)
		fmt.Println(errmsg)
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(errmsg))
		return
	}

	albumList := ""
	for _, item := range albumResp.Items {
		albumList += fmt.Sprintf("%v:%v\n", item.Name, item.ID)
	}

	w.WriteHeader(http.StatusOK)
	w.Write([]byte(albumList))

	// Return the search results component
	component := templates.AlbumGrid(albums)
	component.Render(r.Context(), w)
}
